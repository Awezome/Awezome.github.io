<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>[转] 关于数组的几道面试题  | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="数组求和 求数组中的最大值和最小值 求数组中的最大值和次大值 求数组中出现次数超过一半的元素 求数组中元素的最短距离 求两个有序数组的共同元素 求三个数组的共同元素 找出数组中唯一重复的元素 找出出现奇数次的元素 求数组中满足给定和的数对 最大子段和 最大子段积 数组循环移位 字符串逆转 组合问题 合并两个数组 重排问题 找出绝对值最小的元素">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="[转] 关于数组的几道面试题 ">
<meta property="og:url" content="http://yoursite.com/2014/05/20/e5-85-b3-e4-ba-8e-e6-95-b0-e7-bb-84-e7-9a-84-e5-87-a0-e9-81-93-e9-9d-a2-e8-af-95-e9-a2-98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数组求和 求数组中的最大值和最小值 求数组中的最大值和次大值 求数组中出现次数超过一半的元素 求数组中元素的最短距离 求两个有序数组的共同元素 求三个数组的共同元素 找出数组中唯一重复的元素 找出出现奇数次的元素 求数组中满足给定和的数对 最大子段和 最大子段积 数组循环移位 字符串逆转 组合问题 合并两个数组 重排问题 找出绝对值最小的元素">
<meta property="og:updated_time" content="2018-01-13T05:07:00.483Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[转] 关于数组的几道面试题 ">
<meta name="twitter:description" content="数组求和 求数组中的最大值和最小值 求数组中的最大值和次大值 求数组中出现次数超过一半的元素 求数组中元素的最短距离 求两个有序数组的共同元素 求三个数组的共同元素 找出数组中唯一重复的元素 找出出现奇数次的元素 求数组中满足给定和的数对 最大子段和 最大子段积 数组循环移位 字符串逆转 组合问题 合并两个数组 重排问题 找出绝对值最小的元素">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-e5-85-b3-e4-ba-8e-e6-95-b0-e7-bb-84-e7-9a-84-e5-87-a0-e9-81-93-e9-9d-a2-e8-af-95-e9-a2-98" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/20/e5-85-b3-e4-ba-8e-e6-95-b0-e7-bb-84-e7-9a-84-e5-87-a0-e9-81-93-e9-9d-a2-e8-af-95-e9-a2-98/" class="article-date">
  <time datetime="2014-05-20T00:43:16.000Z" itemprop="datePublished">2014-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [转] 关于数组的几道面试题 
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>数组求和</p>
<p>求数组中的最大值和最小值</p>
<p>求数组中的最大值和次大值</p>
<p>求数组中出现次数超过一半的元素</p>
<p>求数组中元素的最短距离</p>
<p>求两个有序数组的共同元素</p>
<p>求三个数组的共同元素</p>
<p>找出数组中唯一重复的元素</p>
<p>找出出现奇数次的元素</p>
<p>求数组中满足给定和的数对</p>
<p>最大子段和</p>
<p>最大子段积</p>
<p>数组循环移位</p>
<p>字符串逆转</p>
<p>组合问题</p>
<p>合并两个数组</p>
<p>重排问题</p>
<p>找出绝对值最小的元素<br><a id="more"></a></p>
</blockquote>
<p><strong>数组求和 </strong><br>    给定一个含有n个元素的整型数组a，求a中所有元素的和。可能您会觉得很简单，是的，的确简单，但是为什么还要说呢，原因：这道题要求用递归，只用一行代码。<br>分析<br>    简单说一下，两种情况：<br>    1. 如果数组元素个数为0，那么和为0；<br>    2. 如果数组元素个数为n，那么先求出前n-1个元素之和，再加上a[n - 1]即可；<br>代码<br>// 数组求和<br><code>int sum(int*a, int n)
{
     return n ==0?0 : sum(a, n -1) + a[n -1];
}</code></p>
<p><strong>求数组的最大值和最小值</strong><br>    给定一个含有n个元素的整型数组a，求a中的最大值和最小值。<br>分析<br>    常规的做法是遍历一次，分别求出最大值和最小值，事实上，至多3|n/2|（||代表向下取整）就足以找出最小值和最大值。做法是：记录比较过程中遇到的最小值和最大值。我们并不是将每一个输入元素与当前的最大值和最小值进行比较（这样做的代价是每个元素需要两次比较），而是成对的处理元素。先将一对输入元素进行比较，然后把较小者与当前最小值进行比较，把较大者与当前最大值比较，因此每两个元素比较3次。<br>    如何假定当前最小值和最大值的初始值依赖于n是奇数还是偶数。如果n是奇数，就将最小值和最大值都设为第一个元素的值，然后成对的处理余下的元素。如果n是偶数，就对前两个元素做一次比较，以决定最小值和最大值的初值，然后如同n是奇数的情形一样，成对的处理余下的元素。</p>
<pre><code>但是这里要说的是分治法，将数组分成左右两部分，先求出左半部分的最大值和最小值，再求出右半部分的最大值和最小值，然后综合起来求总体的最大值和最小值。这是个递归的过程，对于划分后的左右两部分，同样重复这个过程，直到划分区间内只剩下一个元素或者两个元素。
</code></pre><p>代码<br>// 求数组的最大值和最小值，返回值在maxValue和minValue<br>`void MaxandMin(int *a, int l, int r, int&amp; maxValue, int&amp; minValue)<br>{<br>    if(l == r) // l与r之间只有一个元素<br>    {<br>        maxValue = a[l] ;<br>        minValue = a[l] ;<br>        return ;<br>    }</p>
<pre><code>if(l + 1 == r) // l与r之间只有两个元素
{
    if(a[l] &gt;= a[r])
    {
        maxValue = a[l] ;
        minValue = a[r] ;
    }
    else
    {
        maxValue = a[r] ;
        minValue = a[l] ;
    }
    return ;
}

int m = (l + r) / 2 ; // 求中点

int lmax ; // 左半部份最大值
int lmin ; // 左半部份最小值
MaxandMin(a, l, m, lmax, lmin) ; // 递归计算左半部份

int rmax ; // 右半部份最大值
int rmin ; // 右半部份最小值
MaxandMin(a, m + 1, r, rmax, rmin) ; // 递归计算右半部份

maxValue = max(lmax, rmax) ; // 总的最大值
minValue = min(lmin, rmin) ; // 总的最小值
</code></pre><p>}<br><code>**求数组的最大值和次小值**
    给定一个含有n个元素的整型数组a，求a中的最大值和次小值。
分析
    思路和上一题类似，同样是用分治法，先求出左边的最大值leftmax和次大值leftsecond，再求出右边的最大值rightmax和次大值rightsecond，然后合并，如何合并呢？分情况考虑。    
    1\. 如果leftmax &gt; rightmax，那么可以肯定leftmax是最大值，但次大值不一定是rightmax，但肯定不是rightsecond，只需将leftsecond和rightmax做一次比较即可；
    2\. 如果rightmax &gt; leftmax，那么可以肯定的rightmax是最大值，但次大值不一样是leftmax，但肯定不是leftsecond，所以只需将leftmax与rightsecond做一次比较即可；
注意
    这种方法无法处理最大元素有多个的情况，比如3,5,7,7，将返回7,7而不是7,5。感谢网友，从无到有靠他人指出。
代码
// 找出数组的最大值和次大值，a是待查找的数组，left和right是查找区间，max和second存放结果</code>void MaxandMin(int a[], int left, int right, int&amp;max, int&amp;second)<br>{<br>    if(left == right)<br>    {<br>        max = a[left] ;<br>        second = INT_MIN;<br>    }<br>    elseif(left +1== right)<br>    {<br>        max = a[left] &gt; a[right] ? a[left] : a[right] ;<br>        second = a[left] &lt; a[right] ? a[left] : a[right] ;<br>    }<br>    else<br>    {<br>        int mid = left + (right - left) /2 ;</p>
<pre><code>    int leftmax ;
    int leftsecond ;
    MaxandMin(a, left, mid, leftmax, leftsecond) ;

    int rightmax ;
    int rightsecond ;
    MaxandMin(a, mid +1, right, rightmax, rightsecond) ;

    if (leftmax &gt; rightmax)
    {
        max = leftmax ;
        second = leftsecond &gt; rightmax ? leftsecond : rightmax ;
    }
    else
    {
        max = rightmax ;
        second = leftmax &lt; rightsecond ? rightsecond : leftmax ;
    }
}
</code></pre><p>}`</p>
<p><strong>求数组中出现次数超过一半的元素</strong><br>    给定一个含有n个元素的整型数组a，其中有个元素出现次数超过n/2，求出这个元素。据说是百度的一道题。<br>分析<br>    暂且先不说当前作者的思路，我看到这个问题的时候，想到了如下方法：<br>    1. 先进行排序，常规的方法就是快速排序，平均时间复杂度为O(nlogn))，然后取第n/2个元素即可，当然，这种方法的前提是存在这个所谓的“主元素”；若不清楚，还是需要验证的；<br>    2. 由于肯定该数组中含有这么个元素，该题就转换为找中位数了。找中位数的方法线性时间内有两种：第一、基于分治法的线性期望时间求中位数，该方法是线性期望时间，类似于快速排序；第二、最坏情况下也是线性时间复杂度的方法——“五分中项的中项”划分方法；<br>    3、分治的思想  若a中存在主元素，则将a分为两部分后，a的主元素也必为两部分中至少一部分主元素，因此可用分治法。<br>    将元素划分两部分，递归地检查两部分有无主元素。算法如下：<br>    a. 若a中只含有一个元素，则此元素就是主元素，返回此数；<br>    b. 将a分为两部分a1和a2（二者元素相等或只差一个），分别递归调用此方法求其主元素m1和m2；<br>    c. 若m1和m2都存在且相等，则这个是就是a的主元素，返回次数；<br>    d. 若m1和m2都存在且不相等，则分别检查这两个数是否为a的主元素，若有则返回此数，若无则返回空值；<br>    e. 若m1和m2都不存在，则a无主元素，返回空值；<br>    f. 若m1和m2只有一个存在，则检查这个数是否为a的主元素，若是则返回此数，若否就返回空值；</p>
<pre><code>对于作者给出的这种算法，我在《编程之美》上看到过，即“寻找发帖水王”的题目。
设置一个当前值和当前值的计数器，初始化当前值为数组首元素，计数器值为1，然后从第二个元素开始遍历整个数组，对于每个被遍历到的值a[i]
1\. 如果a[i] == currentvalue，则计数器加1；
2\. 如果a[i]  != currentvalue，则计数器减一，如果计数器等于0，则更新当前值为a[i]，并将计数器值重置为1；
</code></pre><p>代码<br>`void Find(int a[], int length)<br>{<br>    int candidate;<br>    int i, ntimes;<br>    i = 0;<br>    ntimes = 0;</p>
<pre><code>for(i = 0; i &lt; length; i++)
{
    if(ntimes == 0)//计数为0时，读入新的元素，计数加1
    {
        candidate = a[i];
        ntimes = 1;
    }
    else
    {
        if(candidate == a[i])//如果数据相同，计数加1
        {
            ntimes++;
        }
        else
        {
            ntimes--; //如果计数不同，则计数减1，相当于删除了两个元素
        }
    }
}

int count = 0;
for(i = 0; i &lt;length; i++)
{
    if(candidate == a[i])
        count++;
}
//最终得到的candidate元素有可能是序列最末位的两个元素之一
//因此，需要验证
if(count &gt; length/2)
{
    cout &lt;&lt; endl &lt;&lt; &quot;主元素为: &quot; &lt;&lt; candidate &lt;&lt; endl;
}
else
{
    cout &lt;&lt; &quot;没有主元素.&quot; &lt;&lt; endl;
}
</code></pre><p>}`</p>
<p><strong>求数组中元素的最短距离</strong><br>    给定一个含有n个元素的整型数组a，找出数组中的两个元素x和y，使得abs(x - y)值最小。<br>分析<br>    看到这个题目，首先想到的是Brute Force，这样需要的时间复杂度为O(n^2)；<br>    另外，我们可以先进行排序，然后遍历一次数组即可。<br>    不知道还有没有更好的方法？？？？<br>代码<br>`int compare(const void<em> a, const void</em> b)<br>{<br>    return <em>(int</em>)a - <em>(int</em>)b ;<br>}</p>
<p>// 求数组中元素的最短距离<br>void MinimumDistance(int* a, int n)<br>{<br>    // Sort<br>    qsort(a, n, sizeof(int), compare) ;</p>
<pre><code>int i ; // Index of number 1
int j ; // Index of number 2

int minDistance = numeric_limits&lt;int&gt;::max() ;
for (int k = 0; k &lt; n - 1; ++k)
{
    if (a[k + 1] - a[k] &lt; minDistance)
    {
        minDistance = a[k + 1] - a[k] ;
        i = a[k] ;
        j = a[k + 1] ;
    }
}

cout &lt;&lt; &quot;Minimum distance is: &quot; &lt;&lt; minDistance &lt;&lt; endl ;
cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; j = &quot; &lt;&lt; j &lt;&lt; endl ;
</code></pre><p>}<code>**
求两个有序数组的共同元素**
    给定两个含有n个元素的有序（非降序）整型数组a和b，求出其共同元素，比如
    a = 0, 1, 2, 3, 4
    b = 1, 3, 5, 7, 9
    输出1, 3
分析
   充分利用数组有序的性质，用两个指针i和j分别指向a和b，比较a[i]和b[j]，根据比较结果移动指针，则有如下三种情况：
    1\. a[i] &lt; b[j]，则i++，继续比较；
    2\. a[i] == b[j]，则i和j皆加1，继续比较；
    3\. a[i] &gt; b[j]，则j++，继续比较；
    重复以上过程，直至i或j到达数组末尾。
代码
// 找出两个数组的共同元素</code>void FindCommon(int<em> a, int</em> b, int n)<br>{<br>    int i = 0;<br>    int j = 0 ;</p>
<pre><code>while (i &lt; n &amp;&amp; j &lt; n)
{
    if (a[i] &lt; b[j])
        ++i ;
    else if(a[i] == b[j])
    {
        cout &lt;&lt; a[i] &lt;&lt; endl ;
        ++i ;
        ++j ;
    }
    else// a[i] &gt; b[j]
        ++j ;
}
</code></pre><p>}`<br>    这道题还要其他的解法，比如对于a中任意一个元素，在b中对齐进行Bianry Search，因为a中有n个元素，而在b中进行Binary Search需要logn，所以，找出全部相同元素的时间复杂度O(nlogn)。<br>    另外，上面的解法，只要b有序即可，a是否有序无所谓，因为我们只是在b中做Binary Search。如果a也有序的话，那么用上面的方法就有点慢了，因为如果a中某个元素在b中的位置是k的话，那么a中下一个元素在b中的位置一定位于k的右侧，所以本次搜索空间可以根据上次搜索结果缩小，而不是在整个b中搜索。也即如果a和b都有序的话，代码可以做如下修改，记录上次搜索b中的元素位置，作为下一次搜索的起始点。</p>
<p><strong>求三个数组的共同元素</strong><br>    给定三个含有n个元素的整型数组a、b和c，求他们最小的公共元素。<br>分析<br>   如果三个数组都有序，那么可以设置三个指针指向三个数组的头部，然后根据这三个指针所指的值进行比较来移动指针，直到找到共同元素。<br>代码<br>// 三个数组的共同元素-只找最小的<br>`void FindCommonElements(int a[], int b[], int c[], int x, int y, int z)<br>{<br>    for(int i = 0, j = 0, k = 0; i &lt; x &amp;&amp; j &lt; y &amp;&amp; k &lt; z;)<br>    {<br>        if(a[i] &lt; b[j])<br>        {<br>            i++ ;<br>        }<br>        else // a[i] &gt;= b[j]<br>        {<br>            if(b[j] &lt; c[k])<br>            {<br>                j++ ;<br>            }<br>            else // b[j] &gt;= c[k]<br>            {<br>                if(c[k] &lt; a[i])<br>                {<br>                    k++ ;<br>                }<br>                else // c[k] &gt;= a[i]<br>                {<br>                    cout &lt;&lt; c[k] &lt;&lt; endl ;<br>                    return ;<br>                }<br>            }<br>        }<br>    }</p>
<pre><code>cout &lt;&lt; &quot;Not found!&quot; &lt;&lt; endl ;
</code></pre><p>}<code>如果三个数组都没有序的话，可以对a和b进行排序，然后对c中任意一个元素都在b和c中做二分搜索。
// 找出三个数组的共同元素
// O(NlogN)</code>int UniqueCommonItem(int <em>a, int </em>b, int *c, int n)<br>{<br>    // sort array a<br>    qsort(a, n, sizeof(int), compare) ; // NlogN</p>
<pre><code>// sort array b
qsort(b, n, sizeof(int), compare) ; // NlogN

// for each element in array c, do a binary search in a and b
// This is up to a complexity of N*2*logN
for (int i = 0; i &lt; n; i++)
{
    if(BinarySearch(a, n, c[i]) &amp;&amp; BinarySearch(b, n, c[i]))
        return c[i] ;
}

return - 1 ; // not found
</code></pre><p>}`<br>    也可以对a进行排序，然后对于b和c中任意一个元素都在a中进行二分搜索，但是这样做是由问题的：当b[i]和c[i]同时都在a里面也说明不了就是共同元素。</p>
<pre><code>小小总结一下，对于在数组中进行查找的问题，可以分为如下两种情况处理：
1\. 如果给定的数组有序，那么首先应该想到的是二分查找，时间复杂度为（logn）；
2\. 如果给定的数组无序，那么首先应该想到对数组进行排序，很多排序算法都能在O(nlogn)时间内对数组进行排序，然后再使用二分搜索，总的时间复杂度为O(nlogn)。
</code></pre><p><strong>找出数组中唯一的重复元素</strong><br>    给定含有1001个元素的数组，其中存放了1-1000之内的整数，只有一个整数是重复的，其他均只出现一次，每个数组元素只能访问一次。请找出这个数。<br>分析<br>    方法一：当N为比较大的数时警惕溢出<br>    求出整个数组的和，再减去1-1000的和，得到的差即为重复的元素。</p>
<pre><code>方法二：
数组取值操作可以看作一个特殊的函数f: D-&gt;R，定义域为下标值0~1000，值域为1到1000，我们把f(i)叫做它的后继，i叫f(i)的前驱。0只有后继没有前驱，其他数字既有后继又有前驱，重复的那个数字有两个前驱，我们将利用这些特征。
规律：从0开始画一个箭头指向它的后继，从它的后继继续指向后继的后继，这样，必然会有一个节点指向之前已经出现过的数，即为重复的数。
即利用下标与单元中所存储的内容之间的特殊关系，进行遍历访问单元，一旦访问过的单元赋予一个标记，利用标记作为发现重复数字的关键。
代码如下所示。
</code></pre><p>`void FindRepeat(int array[], int length)<br>{<br>    int index = 0;<br>    while ( true )<br>    {<br>       if ( array[index]&lt;0 )<br>           break;<br>       array[index] <em>= -1; //访问过，变成相反数<br>       index=array[index]</em>(-1);</p>
<pre><code>}
cout&lt;&lt;&quot;The repeat number is &quot;&lt;&lt; -array[index] &lt;&lt;endl;
</code></pre><p>}<code>方法三：
    同样考虑下标与内容的关系，不过不用标记，而用两个速度不同的过程来访问。slow每次前进一步，fast每次前进两步，在有环结构中，总会相遇。
    代码如下所示。</code>void FindRepeat(int array[], int length)<br>{<br>    int slow=fast= 0;<br>    while ( true )<br>    {<br>       slow = array[slow];<br>              fast = array[array[fast]];<br>              if( slow == fast )<br>                     break;<br>    }<br>    cout &lt;&lt; slow &lt;&lt; endl;<br>}<code>方法四：异或操作</code>void FindRepeat(int array[], int length)<br>{<br>    int result = 0;<br>    for(int i=1;i&lt;=1000;i++)<br>        result ^= i;<br>    for(int i=0;i&lt;=1000;i++)<br>        result ^= array[i];<br>    cout &lt;&lt; result &lt;&lt; endl;<br>}`</p>
<p><strong>求找出出现奇数次的元素</strong><br>    给定一个含有n个元素的整型数组a，其中只有一个出现奇数次，找出这个元素。<br>分析<br>   因为对于任意一个数k，有k^k = 0，k^ 0 = k，所以将a中所有元素进行异或，那么个数为偶数的元素异或后都变成了0，只留下个数为奇数的那个元素。<br>代码<br>Code highlighting produced by Actipro CodeHighlighter (freeware)<br><a href="http://www.CodeHighlighter.com/--&gt;" target="_blank" rel="noopener">http://www.CodeHighlighter.com/--&gt;</a><br>`int FindElementWithOddCount(int*a, int n)<br>{<br>        int r = a[0] ;</p>
<pre><code>for (int i =1; i &lt; n; ++i)
{
        r ^= a[i] ;
}

return r ;
</code></pre><p>}<code>对于上述题目，出现一个奇数次的数，这样比较好求。但对于下面的题目，该如何求解呢？
    题目：
    有N+2个数，N个数出现了偶数次，2个数出现了奇数次（这两个数不相等），问用O(1)的空间复杂度，找出这两个数，不需要知道具体位置，只需要知道这两个值。
    求解方法如下：
    假设这两个数为a和b，将数组中所有元素异或结果为x = a ^ b，判断x中位为1的位数（注：因为a != b，所以x不等于0，我们只需要知道某一个位为1的位数k，例如0010 1100，我们可以取k = 2,或3， 或者5），然后将x与数组中第k位为1的数进行异或，异或结果为就是a,b中一个，然后用x异或，就可以求出另外一个。
    为什么呢？因为x总第k位为1表示a或b中有一个数的第k位也为1，假设为a，将x与数组中第k位为1的数进行异或时，也即将x与a外加其他第k位为1出现过的偶数次的数进行异或，化简即为x与a异或，结果就是b。
    代码如下所示。</code>void getNum(int a[],int length)<br>{<br>    int s=0;//保存异或结果<br>    for(int i=0;i<length;i++) {="" s="s^a[i];" }="" int="" temp1="s;//临时保存异或结果" temp2="s;//临时保存异或结果" k="0;" while(!(temp1&1))="" 求位为1的位数="">&gt;1;<br>        k++;<br>    }<br>    for(int i=0;i<length;i++) {="" if((a[i]="">&gt;k)&amp;1)//将s与数组中第k位为1的数异或<br>        {<br>            cout&lt;&lt;a[i]&lt;&lt;” “;<br>            s=s^a[i];<br>        }<br>    }<br>    cout&lt;&lt;s&lt;&lt;” “&lt;&lt;(s^temp2)&lt;&lt;endl;//(s^temp2)用来求另外一个数<br>}`</length;i++)></length;i++)></p>
<p><strong>求数组中满足给定和的数对</strong><br>    给定两个含有n个元素的有序整型数组a和b，各有n个元素，求两个数组中满足给定和的数对，即对a中元素i和b中元素j，满足i + j = d(d已知)。<br>分析<br>   两个指针i和j分别指向数组的首尾，然后从两端同时向中间遍历，直到两个指针交叉。<br>代码<br>// 找出满足给定和的数对<br><code>void FixedSum(int* a, int* b, int n, int d)
{
    for (int i = 0, j = n - 1; i &lt; n &amp;&amp; j &gt;= 0)
    {
        if (a[i] + b[j] &lt; d)
            ++i ;
        else if (a[i] + b[j] == d)
        {
            cout &lt;&lt; a[i] &lt;&lt; &quot;, &quot; &lt;&lt; b[j] &lt;&lt; endl ;
            ++i ;
            --j ;
        }
        else // a[i] + b[j] &gt; d
            --j ;
    }
}</code></p>
<p><strong>求最大连续子段和</strong><br>   给定一个整型数组a，求出最大连续子段和，如果和为负数，则按 0计算，比如1， 2， -5， 6， 8，则输出6 + 8  = 14。<br>分析<br>   《编程珠玑》上的经典题目，不多说了。<br>代码<br>// 子数组的最大和<br><code>int Sum(int* a, int n)
{
    int curSum = 0;
    int maxSum = 0;
    for (int i = 0; i &lt; n; i++)
    {
        if (curSum + a[i] &lt; 0)
            curSum = 0;
        else
        {
            curSum += a[i] ;
            maxSum = max(maxSum, curSum);
        }
    }
    return maxSum;
}</code><br><strong>求最大连续子段的乘积</strong><br>    给定一个整型数组a，求出最大连续子段的乘积，比如1， 2， -8， 12， 7则输出12<em>7 = 84。<br>分析<br>   与最大连续字段和类似，注意处理负数的情况。<br>代码<br>// 子数组的最大乘积<br>`int MaxProduct(int </em>a, int n)<br>{<br>    int maxProduct = 1; // max positive product at current position<br>    int minProduct = 1; // min negative product at current position<br>    int r = 1; // result, max multiplication totally</p>
<pre><code>for (int i = 0; i &lt; n; i++)
{
    if (a[i] &gt; 0)
    {
        maxProduct *= a[i];
        minProduct = min(minProduct * a[i], 1);
    }
    else if (a[i] == 0)
    {
        maxProduct = 1;
        minProduct = 1;
    }
    else // a[i] &lt; 0
    {
        int temp = maxProduct;
        maxProduct = max(minProduct * a[i], 1);
        minProduct = temp * a[i];
    }

    r = max(r, maxProduct);
}

return r;
</code></pre><p>}`</p>
<p><strong>数组循环移位</strong><br>    将一个含有n个元素的数组向右循环移动k位，要求时间复杂度为O(n)，且只能使用两个额外的变量，这是在微软的编程之美上看到的。<br>分析<br>   最经典的两种做法：三次翻转、STL中的实现方法（这个看懂了，再补上）。<br>代码<br>// 将buffer中start和end之间的元素逆序<br><code>void Reverse( int buffer[], int start, int end )
{
    while ( start &lt; end )
    {
        int temp = buffer[ start ] ;
        buffer[ start++ ] = buffer[ end ] ;
        buffer[ end-- ] = temp ;
    }
}</code></p>
<p>// 将含有n个元素的数组buffer右移k位<br>`void Shift( int buffer[], int n, int k )<br>{<br>    k %= n ;</p>
<pre><code>Reverse( buffer, 0, n - k - 1) ;
Reverse( buffer, n - k, n - 1 ) ;
Reverse( buffer, 0, n - 1 ) ;
</code></pre><p>}<br>`<br><strong>字符串逆转</strong><br>    给定一个含有n个元素的字符数组a，将其原地逆转。<br>分析<br>    用两个指针分别指向字符数组的首尾部，交换其对应的字符，然后两个指针分别向数组中央移动，直到交叉。<br>代码<br>    略</p>
<p><strong>组合问题</strong><br>    给定一个含有n个元素的整型数组a，从中任取m个元素，求所有组合。比如下面的例子<br>    a = 1, 2, 3, 4, 5<br>    m = 3<br>    输出<br>    1 2 3, 1 2 4, 1 2 5, 1 3 4, 1 3 5, 1 4 5<br>    2 3 4, 2 3 5, 2 4 5<br>    3 4 5<br>分析<br>    典型的排列组合问题，首选回溯法，为了简化问题，将a中的n个元素的值分别设置为1到n。<br>代码<br>// n选m的所有组合<br>`int buffer[100] ;</p>
<p>void PrintArray(int *a, int n)<br>{<br>    for (int i = 0; i &lt; n; ++i)<br>        cout &lt;&lt; a[i] &lt;&lt; “”;<br>    cout &lt;&lt; endl ;<br>}</p>
<p>bool IsValid(int lastIndex, int value)<br>{<br>    for (int i = 0; i &lt; lastIndex; i++)<br>    {<br>        if (buffer[i] &gt;= value)<br>            return false;<br>    }<br>    return true;<br>}</p>
<p>void Select(int t, int n, int m)<br>{<br>    if (t == m)<br>        PrintArray(buffer, m);<br>    else<br>    {<br>        for (int i = 1; i &lt;= n; i++)<br>        {<br>            buffer[t] = i;<br>            if (IsValid(t, i))<br>                Select(t + 1, n, m);<br>        }<br>    }<br>}<br><code>**合并两个数组**
    给定含有n个元素的两个有序数组a和b。合并两个数组中的元素到整型数组c，要求去除重复元素并保持c有序。
分析
    利用合并排序的思想，两个指针i、j和k分别指向数组a、b和c，然后比较两个指针对应元素的大小，有以下三种情况：
    1\. a[i] &lt; b[j]，则c[k] = a[i];
    2\. a[i] == b[j], 则c[k]等于a[i]或b[j]即可；
    3\. a[i] &gt; b[j], 则c[k] = b[j];
    重复以上过程，直到i或者j到达数组末尾，然后将剩下的元素直接copy到数组c中即可。
代码
// 合并两个有序数组</code>void Merge(int <em>a, int </em>b, int *c, int n)<br>{<br>    int i = 0 ;<br>    int j = 0 ;<br>    int k = 0 ;</p>
<pre><code>while (i &lt; n &amp;&amp; j &lt; n)
{
    if (a[i] &lt; b[j])// 如果a的元素小，则插入a中元素到c
    {
        c[k++] = a[i] ;
        ++i ;
    }
    else if (a[i] == b[j])// 如果a和b元素相等，则插入二者皆可，这里插入a
    {
        c[k++] = a[i] ;
        ++i ;
        ++j ;
    }
    else // a[i] &gt; b[j] // 如果b中元素小，则插入b中元素到c
    {
        c[k++] = b[j] ;
        ++j ;
    }
}

if (i == n) // 若a遍历完毕，处理b中剩下的元素
{
    for (int m = j; m &lt; n; ++m)
        c[k++] = b[m] ;
}
else//j == n, 若b遍历完毕，处理a中剩下的元素
{
    for (int m = i; m &lt; n; ++m)
        c[k++] = a[m] ;
}
</code></pre><p>}`</p>
<p><strong>重排问题</strong><br>    给定含有n个元素的整型数组a，其中包括0元素和非0元素，对数组进行排序，要求：<br>    1. 排序后所有0元素在前，所有非0元素在后，且非零元素排序前后相对位置不变<br>    2. 不能使用额外存储空间<br>    例子如下<br>    输入 0， 3， 0， 2， 1， 0， 0<br>    输出 0， 0， 0， 0， 3， 2， 1<br>分析<br>    此排序非传统意义上的排序，因为它要求排序前后非0元素相对位置不变，或者叫整理更恰当。可以从后向前遍历整个数组，遇到某个位置i上的元素是非0元素时，如果a[k]为0，则将a[i]赋值给a[k]，a[k]赋值为0。实际上，i是非0元素的下标，而k是0元素的下标。<br>代码<br><code>void Arrange(int* a, int n)
{
    int k = n -1 ;
    for (int i = n -1; i &gt;=0; --i)
    {
        if (a[i] !=0)
        {
            if (a[k] ==0)
            {
                a[k] = a[i] ;
                a[i] =0 ;
            }
            --k ;
        }
    }
}</code></p>
<p><strong>找出绝对值最小的元素</strong><br>    给定一个有序整数序列（非递减序），可能包含负数，找出其中绝对值最小的元素，比如给定序列 -5, -3, -1, 2, 8 则返回1。<br>分析<br>    由于给定序列是有序的，而这又是搜索问题，所以首先想到二分搜索法，只不过这个二分法比普通的二分法稍微麻烦点，可以分为下面几种情况<br>    1. 如果给定的序列中所有的数都是正数，那么数组的第一个元素即是结果。<br>    2. 如果给定的序列中所有的数都是负数，那么数组的最后一个元素即是结果。<br>    3. 如果给定的序列中既有正数又有负数，那么绝对值得最小值一定出现在正数和负数的连接处。<br>    为什么？因为对于负数序列来说，右侧的数字比左侧的数字绝对值小，如上面的-5, -3, -1, 而对于整数来说，左边的数字绝对值小，比如上面的2, 8，将这个思想用于二分搜索，可先判断中间元素和两侧元素的符号，然后根据符号决定搜索区间，逐步缩小搜索区间，直到只剩下两个元素。<br>代码<br>    单独设置一个函数用来判断两个整数的符号是否相同<br>// 找出一个非递减序整数序列中绝对值最小的数<br>`int MinimumAbsoluteValue(int* a, int n)<br>{<br>    // Only one number in array<br>    if (n ==1)<br>    {<br>        return a[0] ;<br>    }</p>
<pre><code>// All numbers in array have the same sign
if (SameSign(a[0], a[n -1]))
{
    return a[0] &gt;=0? a[0] : a[n -1] ;
}

// Binary search
int l =0 ;
int r = n -1 ;

while(l &lt; r)
{
    if (l +1== r)
    {
        return abs(a[l]) &lt; abs(a[r]) ? a[l] : a[r] ;
    }

    int m = (l + r) /2 ;

    if (SameSign(a[m], a[r]))
    {
        r = m -1;
        continue;
    }
    if (SameSign(a[l], a[m]))
    {
        l = m +1 ;
        continue;
    }
}
</code></pre><p>}<code>上面的代码是有问题的：查找数组a[4]={-2, -1, 3, 4}返回的是3，好像是有点问题。循环中保持的不变式应该是a[l]&lt;0 &amp;&amp; a[r]&gt;0,所以比较中间元a[m]与a[l],a[r]的符号后，要保持不变式，就应该是l=m或者r=。现修正如下。
// 找出一个非递减序整数序列中绝对值最小的数</code>int MinimumAbsoluteValue(int* a, int n)<br>{<br>    // Only one number in array<br>    if (n ==1)<br>    {<br>        return a[0] ;<br>    }</p>
<pre><code>// All numbers in array have the same sign
if (SameSign(a[0], a[n -1]))
{
    return a[0] &gt;=0? a[0] : a[n -1] ;
}

// Binary search
int l =0 ;
int r = n -1 ;

while(l &lt; r)
{
    if (l + 1 == r)
    {
        return abs(a[l]) &lt; abs(a[r]) ? a[l] : a[r] ;
    }

    int m = (l + r) /2 ;

    if (SameSign(a[m], a[r]))
    {
        r = m;
        continue;
    }
    if (SameSign(a[l], a[m]))
    {
        l = m ;
        continue;
    }
}
</code></pre><p>}<br>`</p>
<p>from : <a href="http://blog.chinaunix.net/uid-26548237-id-3753737.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-26548237-id-3753737.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/05/20/e5-85-b3-e4-ba-8e-e6-95-b0-e7-bb-84-e7-9a-84-e5-87-a0-e9-81-93-e9-9d-a2-e8-af-95-e9-a2-98/" data-id="cjccxdzgi001jjpcr97uxi0yj" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/05/21/php-e5-ad-97-e7-ac-a6-e4-b8-b2-e5-92-8c-e6-95-b0-e5-ad-97-e6-af-94-e8-be-83-e6-97-b6-e5-bc-ba-e5-88-b6-e8-bd-ac-e6-8d-a2-e7-9a-84-e9-97-ae-e9-a2-98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          几个有趣的PHP字符串和数字比较时强制转换的例子
        
      </div>
    </a>
  
  
    <a href="/2014/05/19/e5-87-a0-e7-a7-8d-e5-b8-b8-e8-a7-81-e7-9a-84-e6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-e7-9a-84php-e5-ae-9e-e7-8e-b0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">几种常见的排序算法的PHP实现</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Html/">Html</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JQuery/">JQuery</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Windows/">Windows</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt/">Qt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-amp-Fedora/">Linux &amp; Fedora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bootstrap/">bootstrap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/composer/">composer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dex2jar/">dex2jar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/easy-install/">easy_install</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fedora/">fedora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gentoo/">gentoo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https/">https</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ie/">ie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lavarel/">lavarel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcached/">memcached</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mod-wsgi/">mod_wsgi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/phpmyadmin/">phpmyadmin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/phpstorm/">phpstorm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pysvn/">pysvn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-native/">react-native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reviewboard/">reviewboard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rsync/">rsync</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vagrant/">vagrant</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vps/">vps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows8/">windows8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xshell/">xshell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存/">内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大文件/">大文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/局域网/">局域网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打印机/">打印机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序/">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/键盘/">键盘</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-C/" style="font-size: 10px;">C/C++</a> <a href="/tags/Linux/" style="font-size: 18px;">Linux</a> <a href="/tags/Linux-amp-Fedora/" style="font-size: 16px;">Linux &amp; Fedora</a> <a href="/tags/MySQL/" style="font-size: 20px;">MySQL</a> <a href="/tags/Python/" style="font-size: 14px;">Python</a> <a href="/tags/Qt/" style="font-size: 18px;">Qt</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/apache/" style="font-size: 14px;">apache</a> <a href="/tags/bootstrap/" style="font-size: 10px;">bootstrap</a> <a href="/tags/composer/" style="font-size: 10px;">composer</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/dex2jar/" style="font-size: 10px;">dex2jar</a> <a href="/tags/easy-install/" style="font-size: 10px;">easy_install</a> <a href="/tags/fedora/" style="font-size: 10px;">fedora</a> <a href="/tags/gentoo/" style="font-size: 14px;">gentoo</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hadoop/" style="font-size: 12px;">hadoop</a> <a href="/tags/hive/" style="font-size: 12px;">hive</a> <a href="/tags/html/" style="font-size: 12px;">html</a> <a href="/tags/https/" style="font-size: 10px;">https</a> <a href="/tags/ie/" style="font-size: 12px;">ie</a> <a href="/tags/java/" style="font-size: 12px;">java</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/lavarel/" style="font-size: 10px;">lavarel</a> <a href="/tags/memcached/" style="font-size: 10px;">memcached</a> <a href="/tags/mod-wsgi/" style="font-size: 12px;">mod_wsgi</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/phpmyadmin/" style="font-size: 14px;">phpmyadmin</a> <a href="/tags/phpstorm/" style="font-size: 12px;">phpstorm</a> <a href="/tags/pysvn/" style="font-size: 10px;">pysvn</a> <a href="/tags/react/" style="font-size: 12px;">react</a> <a href="/tags/react-native/" style="font-size: 12px;">react-native</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/reviewboard/" style="font-size: 12px;">reviewboard</a> <a href="/tags/rsync/" style="font-size: 10px;">rsync</a> <a href="/tags/sublime/" style="font-size: 10px;">sublime</a> <a href="/tags/vagrant/" style="font-size: 12px;">vagrant</a> <a href="/tags/vps/" style="font-size: 10px;">vps</a> <a href="/tags/windows8/" style="font-size: 10px;">windows8</a> <a href="/tags/xshell/" style="font-size: 10px;">xshell</a> <a href="/tags/内存/" style="font-size: 10px;">内存</a> <a href="/tags/大数据/" style="font-size: 10px;">大数据</a> <a href="/tags/大文件/" style="font-size: 12px;">大文件</a> <a href="/tags/局域网/" style="font-size: 10px;">局域网</a> <a href="/tags/打印机/" style="font-size: 10px;">打印机</a> <a href="/tags/排序/" style="font-size: 10px;">排序</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/算法/" style="font-size: 18px;">算法</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/键盘/" style="font-size: 10px;">键盘</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">February 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">October 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">July 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">May 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">April 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">March 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">February 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">January 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">December 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">November 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">October 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">September 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/08/">August 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/06/">June 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/02/">February 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/09/">September 2008</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/13/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/10/26/e8-a7-a3-e5-86-b3ssh-e8-bf-9c-e7-ab-afvim-e4-b8-ad-e6-96-87-e4-b9-b1-e7-a0-81-e7-9a-84-e9-97-ae-e9-a2-98/">解决ssh 远端vim中文乱码的问题</a>
          </li>
        
          <li>
            <a href="/2016/06/10/e8-bd-ac-reactreact-native-e7-9a-84es5-es6-e5-86-99-e6-b3-95-e5-af-b9-e7-85-a7-e8-a1-a8/">[转] React/React Native 的ES5 ES6写法对照表</a>
          </li>
        
          <li>
            <a href="/2016/06/09/react-native-mac-e4-b8-8b-android-e7-8e-af-e5-a2-83-e5-8f-8aide-e9-85-8d-e7-bd-ae/">React Native : Mac 下 Android 环境及IDE配置</a>
          </li>
        
          <li>
            <a href="/2016/06/05/modern-php-e4-bc-a0-e5-80-bc-e3-80-81-e5-bc-95-e7-94-a8-e5-92-8c-e5-af-b9-e8-b1-a1-e6-a0-87-e8-af-86-e7-ac-a6/">Modern PHP : 传值、引用和对象标识符</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>