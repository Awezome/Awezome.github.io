---
title: android cpu调节模式和io调度模式详解
id: 1094
categories:
  - Other
date: 2012-11-16 20:47:18
tags:
---

CPU模式:

ondemand
【按需模式】
官方及xray内核默认为此项调节模式，顾名思义，按需调节cpu频率，不操作手机的时候控制在最低频率，滑屏或进入应用后会迅速提升至最高频率，当空闲时迅速降低频率，性能较稳定，但因频率变化幅度过大，省电方面只有一般的水平。

powersave
【省电模式】
按设定最低频率运行，日常没有使用价值，除非配合setcpu情景模式，关屏睡眠时使用此调节模式

performance
【高性能模式】
和省电模式相反，始终按设定最高频率运行，此模式亦无任何日常使用价值，果断pass

userspace
【用户隔离】
严格来说它并不是一个模式，是允许非内核进程控制cpu频率的设置，现在已经不需要它了，setcpu官方的建议是，“不要使用此选项”。

conservative
【保守模式】
和ondemand模式的调频设定类似，不过有操作时提升cpu频率的速度较慢，空闲时迅速降频，所以名字叫保守模式，性能较低，省电程度略好于ondemand，总体不推荐

interactive
【交互模式】
相对于保守模式，这个模式算是高性能版的ondemand，开始操作手机后，频率升至最高，可以带来更好的响应速度，空闲时缓慢降至设定最低频率。电量自然也是要多费一点。

interactivex
交互模式的修改优化版，开屏后进入更好的频率管理方式，比交互模式略省电。

hotplug
ray没有此模式，多核机型上可用，在不需要的时候关闭多余核心，其他部分调节方式与ondemand相同。

smartass
【智能调节模式】
相当于是一个预置的profile，交互模式的另一个修改版，更加省电。根据资源使用智能提供一个适中的频率，空闲时自动降频，锁屏时自动固定频率。特色是锁屏后非常省电。缺点是部分机型锁屏一段时间后容易睡死。

smartassv2
【智能调节模式v2】
aire内核默认，smartass的升级版，最近很流行的模式。能利用cpu设定的所有频率值。算是对cpu利用充分的条件下最省电的一个模式。同系列的优缺点依旧存在。

smoothass
介绍是比smartass“更有活力的渐进式频率调节”，没用过不太清楚。

brazilianwax
与smoothass相同的模式。

savagedzen
基于smartass的另一模式，在耗电和性能间取得更佳的均衡点。

minmax
保守模式的优化配置版，耗电略高于smartassv2，性能较好。

scary
基于保守模式，同时具有smartass的特点。看介绍是很奇怪的一个模式，有人说不错，不过自己没有试过。

lagfree
【无延迟模式】
基本基于保守模式的频率调节机制，频率上升缓慢，不同之处在于唤醒屏幕后会直接跳跃到一个合适的频率，减少亮起以后的延迟现象。但日常使用性能不高。

intellidemand
【智能按需调节模式】
这个模式有点意思，可根据GPU使用情况来针对性调节cpu频率，GPU负载高时，比如运行游戏和测试的时候，cpu频率会迅速升至最高，这时的调节模式类似于ondemand；当GPU空闲时则会自动限制cpu最高频率，更加省电。要游戏性能好，又要省电的可以用下试试。

I/O调度模式：
（i/o即input/output的缩写，关于数据的读写操作，不同进程请求数据的优先顺序等等。io调度模式比较复杂，我没有具体测试，这里仅对ray上出现的几个模式做说明，部分参考xda、androidforums、wik1pedia、linuxarchive资料）

noop
这个调度模式会把所有的数据请求直接合并到一个简单的队列里。不适合有机械结构的存储器，因为没有优化顺序，会增加额外的寻道时间。属于最简单的一个调度模式，无视io操作优先级和复杂性，执行完一个再执行一个，如果读写操作繁多的话，就会造成效率降低。

anticipatory
其实这个有点类似于pc硬盘的NCQ功能，执行有预测性的调度，看起来似乎可以提高效率，不过因为它的预测机制会在进程将要结束一个读写操作时时开始准备下一个的预处理，所以会打乱系统正常的连续io调度，降低随机存取效率。用的人很少，不推荐。

deadline
顾名思义，用过期时间来排序io操作顺序，保证先出现的io请求有最短的延迟时间，相对于写操作，给读操作更优先的级别。是比较好的一个调度模式。

cfq
完全公平队列，是anticipatory模式的替代品，没有过多的做预测性调度，而是根据给定的进程io优先级，直接来分配操作的顺序。这个模式在linux上表现良好，但也许并不是最适合android的io调度模式，太强调均衡，而降低了连续读写数据的性能。

vr
具有和deadline相似的操作排序机制，有着最高的峰值读写速度，但是性能比较不稳定，也就是说可能跑出最高的分数，但是也会出现最低值。

sio
虽然基于deadline，但是它和noop一样，不会对io操作进行排序，所以有着noop那样快速的存取速度，但并没有过多优化io操作。如果不喜欢noop完全不参与调度，也可以选择这个。

总体而言，推荐指数依次为sio=deadline(两种趋向，一种少干预，一种多干预)>vr(性能可以达到最高峰值)>cfq=noop>anticipatory
